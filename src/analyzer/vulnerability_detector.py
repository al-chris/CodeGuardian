import ast
import re
import os
import subprocess
from typing import List, Dict, Any, Optional

# Import built-in static analyzers
import bandit
from pylint import epylint as lint

class VulnerabilityDetector:
    """Detects security vulnerabilities in code."""
    
    def __init__(self):
        # Vulnerability patterns by language
        self.patterns = {
            'Python': {
                'sql_injection': [
                    r'cursor\.execute\s*\(.+\+\s*.+\)',
                    r'cursor\.executemany\s*\(.+\+\s*.+\)',
                    r'execute\s*\(.+\%\s*.+\)',
                ],
                'command_injection': [
                    r'os\.system\s*\(.+\+\s*.+\)',
                    r'subprocess\.call\s*\(.+\+\s*.+\)',
                    r'subprocess\.Popen\s*\(.+\+\s*.+\)',
                    r'eval\s*\(.+\)',
                ],
                'path_traversal': [
                    r'open\s*\(.+\+\s*.+\)',
                    r'file\s*\(.+\+\s*.+\)',
                ],
                'insecure_deserialization': [
                    r'pickle\.loads\s*\(',
                    r'json\.loads\s*\(.+untrusted',
                    r'yaml\.load\s*\(.+Loader=None\)',
                ],
                'hardcoded_secrets': [
                    r'password\s*=\s*[\"\'](?!.*\$\{)(?!.*\{\{).*[\"\']',
                    r'secret\s*=\s*[\"\'](?!.*\$\{)(?!.*\{\{).*[\"\']',
                    r'api[-_]?key\s*=\s*[\"\'](?!.*\$\{)(?!.*\{\{).*[\"\']',
                ],
            },
            'JavaScript': {
                # JavaScript patterns would go here
            },
            # Add more languages as needed
        }
        
        # Risk levels for vulnerability types
        self.risk_levels = {
            'sql_injection': 'critical',
            'command_injection': 'critical',
            'path_traversal': 'high',
            'insecure_deserialization': 'high',
            'hardcoded_secrets': 'medium',
            'xss': 'high',
            'weak_crypto': 'medium',
            'insecure_random': 'medium',
        }
    
    def scan_file(self, file_path: str) -> List[Dict[str, Any]]:
        """Scan a file for vulnerabilities."""
        vulnerabilities = []
        
        _, ext = os.path.splitext(file_path)
        language = self._get_language_from_extension(ext)
        
        if not language or language not in self.patterns:
            return []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            # Perform pattern-based detection
            pattern_vulns = self._pattern_scan(content, language, file_path)
            vulnerabilities.extend(pattern_vulns)
            
            # Language-specific scanners
            if language == 'Python':
                python_vulns = self._scan_python_file(file_path, content)
                vulnerabilities.extend(python_vulns)
                
            # Add other language scanners here
            
            return vulnerabilities
            
        except Exception as e:
            print(f"Error scanning {file_path}: {str(e)}")
            return []
    
    def _get_language_from_extension(self, ext: str) -> Optional[str]:
        """Map file extension to language."""
        extension_map = {
            '.py': 'Python',
            '.js': 'JavaScript',
            '.ts': 'TypeScript',
            '.java': 'Java',
            # Add more mappings as needed
        }
        return extension_map.get(ext.lower())
    
    def _pattern_scan(self, content: str, language: str, file_path: str) -> List[Dict[str, Any]]:
        """Scan content using regex patterns."""
        vulnerabilities = []
        
        for vuln_type, patterns in self.patterns.get(language, {}).items():
            for pattern in patterns:
                matches = re.finditer(pattern, content)
                for match in matches:
                    line_num = content[:match.start()].count('\n') + 1
                    line_content = content.split('\n')[line_num - 1]
                    
                    vulnerabilities.append({
                        'file_path': file_path,
                        'line': line_num,
                        'column': match.start() - content.rfind('\n', 0, match.start()) - 1,
                        'type': vuln_type,
                        'risk_level': self.risk_levels.get(vuln_type, 'low'),
                        'description': f"Potential {vuln_type.replace('_', ' ')} vulnerability detected",
                        'code_snippet': line_content.strip(),
                        'confidence': 'medium',  # Pattern-based detection has medium confidence
                    })
        
        return vulnerabilities
    
    def _scan_python_file(self, file_path: str, content: str) -> List[Dict[str, Any]]:
        """Scan Python file using specialized tools and AST analysis."""
        vulnerabilities = []
        
        # Run Bandit
        bandit_vulns = self._run_bandit(file_path)
        vulnerabilities.extend(bandit_vulns)
        
        # Run PyLint
        pylint_vulns = self._run_pylint(file_path)
        vulnerabilities.extend(pylint_vulns)
        
        # Parse AST for additional checks
        ast_vulns = self._analyze_python_ast(content, file_path)
        vulnerabilities.extend(ast_vulns)
        
        return vulnerabilities
        
    def _run_bandit(self, file_path: str) -> List[Dict[str, Any]]:
        """Run Bandit security linter."""
        vulnerabilities = []
        
        try:
            # Configure Bandit to run on the file
            bandit_args = ['-f', 'json', '-q', file_path]
            bandit_result = bandit.main(bandit_args)
            
            # Process results
            if bandit_result and isinstance(bandit_result, tuple) and len(bandit_result) > 1:
                results = bandit_result[1]
                if isinstance(results, str):
                    import json
                    try:
                        results_dict = json.loads(results)
                        for result in results_dict.get('results', []):
                            vulnerabilities.append({
                                'file_path': file_path,
                                'line': result.get('line_number', 0),
                                'type': 'security_' + result.get('test_id', 'unknown'),
                                'risk_level': result.get('issue_severity', 'low'),
                                'description': result.get('issue_text', ''),
                                'code_snippet': result.get('code', ''),
                                'confidence': result.get('issue_confidence', 'low'),
                                'detector': 'bandit',
                            })
                    except json.JSONDecodeError:
                        pass
                        
        except Exception as e:
            print(f"Error running Bandit on {file_path}: {str(e)}")
            
        return vulnerabilities
    
    def _run_pylint(self, file_path: str) -> List[Dict[str, Any]]:
        """Run PyLint for code quality issues."""
        vulnerabilities = []
        
        try:
            # Run PyLint
            (pylint_stdout, pylint_stderr) = lint.py_run(
                command_options=f'{file_path} --output-format=json',
                return_std=True
            )
            
            output = pylint_stdout.getvalue()
            
            # Process results
            import json
            try:
                results = json.loads(output)
                for result in results:
                    # Filter for security-related issues
                    msg_id = result.get('message-id', '')
                    if any(prefix in msg_id for prefix in ['security', 'W0', 'E0', 'F0']):
                        vulnerabilities.append({
                            'file_path': file_path,
                            'line': result.get('line', 0),
                            'column': result.get('column', 0),
                            'type': 'code_quality_' + result.get('symbol', 'unknown'),
                            'risk_level': 'medium' if msg_id.startswith(('E', 'F')) else 'low',
                            'description': result.get('message', ''),
                            'code_snippet': result.get('message', '').split('\n')[0] if result.get('message') else '',
                            'confidence': 'medium',
                            'detector': 'pylint',
                        })
            except json.JSONDecodeError:
                pass
                
        except Exception as e:
            print(f"Error running PyLint on {file_path}: {str(e)}")
            
        return vulnerabilities
    
    def _analyze_python_ast(self, content: str, file_path: str) -> List[Dict[str, Any]]:
        """Analyze Python code using AST."""
        vulnerabilities = []
        
        try:
            parsed_ast = ast.parse(content)
            
            # Custom AST visitor to find issues
            class VulnerabilityVisitor(ast.NodeVisitor):
                def __init__(self, content, file_path):
                    self.content = content
                    self.file_path = file_path
                    self.issues = []
                    
                def visit_Call(self, node):
                    # Check for dangerous function calls
                    if isinstance(node.func, ast.Name):
                        func_name = node.func.id
                        dangerous_funcs = {
                            'eval': 'critical',
                            'exec': 'critical',
                            'pickle.loads': 'high',
                            'marshal.loads': 'high',
                            'input': 'low'
                        }
                        
                        if func_name in dangerous_funcs:
                            line_num = node.lineno
                            col_num = node.col_offset
                            content_lines = self.content.split('\n')
                            code_snippet = content_lines[line_num-1] if line_num <= len(content_lines) else ""
                            
                            self.issues.append({
                                'file_path': self.file_path,
                                'line': line_num,
                                'column': col_num,
                                'type': f'dangerous_function_{func_name}',
                                'risk_level': dangerous_funcs[func_name],
                                'description': f"Use of potentially dangerous function '{func_name}'",
                                'code_snippet': code_snippet.strip(),
                                'confidence': 'high',
                                'detector': 'ast_analysis'
                            })
                    
                    self.generic_visit(node)
            
            visitor = VulnerabilityVisitor(content, file_path)
            visitor.visit(parsed_ast)
            vulnerabilities.extend(visitor.issues)
            
        except SyntaxError:
            # If there's a syntax error, we can't parse the AST
            pass
        except Exception as e:
            print(f"Error in AST analysis for {file_path}: {str(e)}")
            
        return vulnerabilities