import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
import joblib
import os
from typing import Dict, Any, List, Optional

class VulnerabilityClassifier:
    """ML-based classifier for vulnerability prioritization and categorization."""
    
    def __init__(self, model_path: Optional[str] = None):
        self.vectorizer = None
        self.model = None
        self.categories = [
            "SQL Injection", 
            "Command Injection",
            "Cross-Site Scripting (XSS)",
            "Path Traversal",
            "Information Disclosure",
            "Insecure Deserialization",
            "Authentication Issues",
            "Authorization Issues",
            "Cryptographic Issues",
            "Input Validation",
            "Code Quality"
        ]
        
        # Load or create model
        if model_path and os.path.exists(model_path):
            self._load_model(model_path)
        else:
            self._create_default_model()
    
    def _create_default_model(self):
        """Create a default model when no trained model is available."""
        # Generate some simple training data
        # This is just for demonstration - in a real app, you'd use a real dataset
        training_data = [
            "SELECT * FROM users WHERE username='input'",
            "cursor.execute('SELECT * FROM users WHERE id = ' + user_id)",
            "os.system('rm -rf ' + directory)",
            "subprocess.call('grep ' + query + ' file.txt', shell=True)",
            "eval(user_input)",
            "password = 'hardcoded_secret123'",
            "open(filename + user_input, 'r')",
            "pickle.loads(untrusted_data)",
            "<script>alert(document.cookie)</script>",
            "response.write('<div>' + user_input + '</div>')",
            "md5(password)",
            "random.random() * 1000",
        ]
        
        # Simple labels (0-10 corresponding to self.categories)
        labels = [0, 0, 1, 1, 1, 4, 3, 5, 2, 2, 8, 8]
        
        # Create vectorizer and model
        self.vectorizer = TfidfVectorizer(max_features=1000)
        X = self.vectorizer.fit_transform(training_data)
        
        self.model = RandomForestClassifier(n_estimators=10)
        self.model.fit(X, labels)
    
    def _load_model(self, model_path: str):
        """Load trained model from disk."""
        model_data = joblib.load(model_path)
        self.vectorizer = model_data.get('vectorizer')
        self.model = model_data.get('model')
        
    def save_model(self, model_path: str):
        """Save trained model to disk."""
        os.makedirs(os.path.dirname(model_path), exist_ok=True)
        model_data = {
            'vectorizer': self.vectorizer,
            'model': self.model
        }
        joblib.dump(model_data, model_path)
    
    def extract_features(self, vulnerability: Dict[str, Any]) -> str:
        """Extract features from a vulnerability dict for classification."""
        features = []
        
        # Extract code snippet
        if 'code_snippet' in vulnerability:
            features.append(vulnerability['code_snippet'])
        
        # Extract vulnerability type
        if 'type' in vulnerability:
            features.append(vulnerability['type'].replace('_', ' '))
        
        # Extract description
        if 'description' in vulnerability:
            features.append(vulnerability['description'])
        
        return " ".join(features)
    
    def classify(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Classify and enrich a vulnerability."""
        if not self.vectorizer or not self.model:
            return self._default_classification(vulnerability)
            
        try:
            # Extract features
            features = self.extract_features(vulnerability)
            
            # Vectorize
            X = self.vectorizer.transform([features])
            
            # Predict category
            category_idx = self.model.predict(X)[0]
            category = self.categories[int(category_idx)] if category_idx < len(self.categories) else "Other"
            
            # Get prediction probabilities
            probs = self.model.predict_proba(X)[0]
            confidence = float(np.max(probs))
            
            # Calculate priority score (0-100)
            risk_factor = self._get_risk_factor(vulnerability)
            priority_score = int(confidence * risk_factor * 100)
            
            return {
                'category': category,
                'confidence': confidence,
                'priority_score': min(priority_score, 100),
                'suggested_actions': self._get_suggested_actions(category, vulnerability),
                'cwe_id': self._map_to_cwe(vulnerability),
                'learning_resources': self._get_learning_resources(category)
            }
            
        except Exception as e:
            print(f"Classification error: {str(e)}")
            return self._default_classification(vulnerability)
    
    def _default_classification(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Provide a default classification when ML fails."""
        vuln_type = vulnerability.get('type', '').lower()
        
        # Simple rule-based matching
        for i, category in enumerate(self.categories):
            if category.lower().replace(' ', '_') in vuln_type:
                return {
                    'category': category,
                    'confidence': 0.7,
                    'priority_score': self._get_risk_factor(vulnerability) * 70,
                    'suggested_actions': self._get_suggested_actions(category, vulnerability),
                    'cwe_id': self._map_to_cwe(vulnerability),
                    'learning_resources': self._get_learning_resources(category)
                }
        
        # Default values
        return {
            'category': "Code Quality",
            'confidence': 0.5,
            'priority_score': 50,
            'suggested_actions': ["Review code", "Add unit tests", "Consider refactoring"],
            'cwe_id': None,
            'learning_resources': ["https://owasp.org/www-project-top-ten/"]
        }
    
    def _get_risk_factor(self, vulnerability: Dict[str, Any]) -> float:
        """Calculate risk factor based on vulnerability properties."""
        risk_level = vulnerability.get('risk_level', 'low').lower()
        
        risk_factors = {
            'critical': 1.0,
            'high': 0.8,
            'medium': 0.6,
            'low': 0.4,
            'info': 0.2
        }
        
        return risk_factors.get(risk_level, 0.5)
    
    def _get_suggested_actions(self, category: str, vulnerability: Dict[str, Any]) -> List[str]:
        """Get suggested actions based on vulnerability category."""
        actions_map = {
            "SQL Injection": [
                "Use parameterized queries",
                "Apply input validation",
                "Implement ORM",
                "Use stored procedures"
            ],
            "Command Injection": [
                "Avoid system calls with user input",
                "Use safe APIs",
                "Implement strict input validation",
                "Consider safer alternatives"
            ],
            "Cross-Site Scripting (XSS)": [
                "Use context-specific output encoding",
                "Implement Content Security Policy",
                "Sanitize user input",
                "Use modern frameworks with auto-escaping"
            ],
            # Add more categories as needed
        }
        
        return actions_map.get(category, ["Review code", "Add tests", "Consider refactoring"])
    
    def _map_to_cwe(self, vulnerability: Dict[str, Any]) -> Optional[int]:
        """Map vulnerability to Common Weakness Enumeration (CWE) ID."""
        vuln_type = vulnerability.get('type', '').lower()
        
        cwe_map = {
            'sql_injection': 89,
            'command_injection': 77,
            'xss': 79,
            'path_traversal': 22,
            'information_disclosure': 200,
            'insecure_deserialization': 502,
            'weak_crypto': 327,
            'hardcoded_secrets': 798
        }
        
        for key, cwe_id in cwe_map.items():
            if key in vuln_type:
                return cwe_id
                
        return None
    
    def _get_learning_resources(self, category: str) -> List[str]:
        """Get learning resources based on vulnerability category."""
        resources_map = {
            "SQL Injection": [
                "https://owasp.org/www-community/attacks/SQL_Injection",
                "https://portswigger.net/web-security/sql-injection"
            ],
            "Command Injection": [
                "https://owasp.org/www-community/attacks/Command_Injection",
                "https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html"
            ],
            # Add more categories as needed
        }
        
        default_resources = [
            "https://owasp.org/www-project-top-ten/",
            "https://cheatsheetseries.owasp.org/"
        ]
        
        return resources_map.get(category, default_resources)